{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Actividad Unidad 1 - Tarea 1 (Prueba de aplicaciones) En esta tarea se analiza, corrige, ejecuta y testea una aplicaci\u00f3n desarrollada en Python \u00cdndice Objetivos Desarrollo Reflexi\u00f3n Objetivos Para la realizaci\u00f3n de esta tarea se tiene en cuenta el cumplimiento de los siguientes objetivos: Analisis y comprensi\u00f3n del c\u00f3digo Uso de herramientas del IDE para ejecuci\u00f3n, depuraci\u00f3n paso a paso y seguimiento del flujo de control Dise\u00f1ar, implementar y ejecutar pruebas unitarias que cubran las funciones y l\u00f3gica del programa Ejecuci\u00f3n del programa en un entorno controlado para simular su comportamiento en un contexto real Desarrollo La actividad se ha desarrollado en las siguientes fases: Documentaci\u00f3n y prueba del programa Realizaci\u00f3n de los test unitarios del programa Ejecucion del programa en un entorno controlado (sandbox) Reflexi\u00f3n Los resultados y conclusiones tras finalizar la tarea se pueden ver aqui: Resultados y conclusiones Siguiente paso (documentaci\u00f3n y prueba)->","title":"Home"},{"location":"#actividad-unidad-1-tarea-1-prueba-de-aplicaciones","text":"En esta tarea se analiza, corrige, ejecuta y testea una aplicaci\u00f3n desarrollada en Python \u00cdndice Objetivos Desarrollo Reflexi\u00f3n","title":"Actividad Unidad 1 - Tarea 1 (Prueba de aplicaciones)"},{"location":"#objetivos","text":"Para la realizaci\u00f3n de esta tarea se tiene en cuenta el cumplimiento de los siguientes objetivos: Analisis y comprensi\u00f3n del c\u00f3digo Uso de herramientas del IDE para ejecuci\u00f3n, depuraci\u00f3n paso a paso y seguimiento del flujo de control Dise\u00f1ar, implementar y ejecutar pruebas unitarias que cubran las funciones y l\u00f3gica del programa Ejecuci\u00f3n del programa en un entorno controlado para simular su comportamiento en un contexto real","title":"Objetivos"},{"location":"#desarrollo","text":"La actividad se ha desarrollado en las siguientes fases: Documentaci\u00f3n y prueba del programa Realizaci\u00f3n de los test unitarios del programa Ejecucion del programa en un entorno controlado (sandbox)","title":"Desarrollo"},{"location":"#reflexion","text":"Los resultados y conclusiones tras finalizar la tarea se pueden ver aqui: Resultados y conclusiones Siguiente paso (documentaci\u00f3n y prueba)->","title":"Reflexi\u00f3n"},{"location":"documentacionYprueba/","text":"Documentaci\u00f3n y prueba del programa En este paso se procede a la documentaci\u00f3n del codigo mediante comentarios a lo largo de los dos archivos presentes de codigo fuente, ejecuci\u00f3n del programa y realizar algunos arreglos para que se ejecute correctamente el programa Documentaci\u00f3n A continuaci\u00f3n se muestran los dos archivos documentados: 1-. main_app.py # main_app.py # Importar la clase desde el otro archivo (m\u00f3dulo) from lavadero import Lavadero # MODIFICACI\u00d3N CLAVE AQU\u00cd: La funci\u00f3n ahora acepta 3 argumentos def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado): \"\"\" Simula el proceso de lavado para un veh\u00edculo con las opciones dadas. Ahora acepta una instancia de lavadero. :param lavadero: Instancia de Lavadero. :param prelavado: bool, True si se solicita prelavado a mano. :param secado_mano: bool, True si se solicita secado a mano. :param encerado: bool, True si se solicita encerado. \"\"\" print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\") # Mostrar las opciones solicitadas print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\") # 1. Iniciar el lavado try: # Esto establece las opciones y pasa a Fase 0 (Inactivo, pero Ocupado=True) lavadero.hacerLavado(prelavado, secado_mano, encerado) print(\"\\nCoche entra. Estado inicial:\") lavadero.imprimir_estado() # 2. Avanza por las fases print(\"\\nAVANZANDO FASE POR FASE:\") # Usamos un contador para evitar bucles infinitos en caso de error o bucles inesperados pasos = 0 while lavadero.ocupado and pasos < 20: # El cobro ahora ocurre en la primera llamada a avanzarFase (transici\u00f3n 0 -> 1) lavadero.avanzarFase() print(f\"-> Fase actual: \", end=\"\") lavadero.imprimir_fase() print() pasos += 1 print(\"\\n----------------------------------------\") print(\"Lavado completo. Estado final:\") lavadero.imprimir_estado() print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\") print(\"----------------------------------------\") except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2) print(f\"ERROR DE ARGUMENTO: {e}\") except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3) print(f\"ERROR DE ESTADO: {e}\") except Exception as e: print(f\"ERROR INESPERADO: {e}\") # Punto de entrada (main): Aqu\u00ed pasamos los par\u00e1metros if __name__ == \"__main__\": lavadero_global = Lavadero() # Usamos una \u00fanica instancia para acumular ingresos # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14) # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True) # EJEMPLO 2: Lavado r\u00e1pido sin extras (Requisito 9) # Precio esperado: 5.00 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False) # EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2) print(\"\\n=======================================================\") print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True) # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False, encerado=False) 2-. lavadero.py # lavadero.py class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" # Se declaran las constantes con los valores de cada de las fases del lavadero FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 # Constructor para la inicializaci\u00f3n del lavadero def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado # Asigna la fase en \"Inactivo\" y resetea las opciones de lavado a \"false\", requisito 1 def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False # Inicializa un ciclo de lavado segun los parametros dados y valida que los parametros recibidos sean correctos def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" if self.__ocupado: # Si el lavadero est\u00e1 ocupado no se podra iniciar otro lavado diferente raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: # Si no esta secado a mano el coche no se podra seleccionar el encerado raise ValueError(\"No se puede encerar el coche sin secado a mano\") # Se asigna el estado del lavado, se reserva el lavadero para este lavado y se asignan las opciones marcadas para el lavado self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado # Calcula el coste del lavado a cobrar def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.00 if self.__encerado: coste_lavado += 1.20 self.__ingresos += coste_lavado return coste_lavado # Avanza la fase actual segun el transcurso de la ejecuci\u00f3n y las opciones seleccionadas def avanzarFase(self): if not self.__ocupado: # Si esta ocupado no permitira avanzar de faser return \"\"\" Si esta inactivo se asigna el coste cobrado, se actualiza a la fase cobrando y se muestra por consola el coste cobrado \"\"\" if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO # Si est\u00e1 en la fase \"cobrando\" y se ha marcado \"prelavado a mano\" pasa a la fase \"prelavado a mano\" else: self.__fase = self.FASE_ECHANDO_AGUA # Si est\u00e1 en la fase \"cobrando\" pero no se ha marcado \"prelavado a mano\" pasa a la fase \"echando agua\" elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA # Si est\u00e1 en la fase \"prelavado a mano\" pasa a la fase \"echando agua\" elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO # Si est\u00e1 en la fase \"echando agua\" pasa a la fase \"enjabonando\" elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS # Si esta en la fase \"enjabonando\" pasa a la fase \"rodillos\" elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO # Si est\u00e1 en la fase \"rodillos\" y se ha marcado \"secado a mano\" pasa a la fase \"secado a mano\" else: self.__fase = self.FASE_SECADO_AUTOMATICO # Si est\u00e1 en la fase \"rodillos\" pero no se ha marcado \"secado a mano\" pasa a la fase \"secado autom\u00e1tico\" elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() # Si est\u00e1 en la fase de secado autom\u00e1tico se ejectua la funci\u00f3n terminar() elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO # Si est\u00e1 en la fase \"secado a mano\" y marcado \"encerado\" pasa a la fase \"encerado\", sino ejecuta la funcion terminar() else: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() # Si est\u00e1 en la fase \"encerado\" se ejecuta la funci\u00f3n terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") # Si est\u00e1 en cualquier fase que no sea ninguna de las anteriores se lanza un error en tiempo de ejecuci\u00f3n # Mapea todas las fases posibles en el programa y muestra la fase actual def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") # Muestra el estado de general del lavadero def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self.hacerLavado(prelavado, secado, encerado) fases_visitadas = [self.fase] while self.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.avanzarFase() fases_visitadas.append(self.fase) return fases_visitadas Soluci\u00f3n de errores y ejecuci\u00f3n Durante el proceso de documentaci\u00f3n y ejecuci\u00f3n se detectan 2 fallos : 1-. main_app.py (linea 83): En la llamada a la funci\u00f3n ejecutarSimulacion() le falta un parametro, el parametro encerado=false # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False, encerado=False) 2-. lavadero.py (linea 136-141): Error en una de las fases tras realizar un lavado con todos los extras a N (False), ya que al avanzar la fase de \"pasando rodillos\" a \"secado automatico\", pasa a \"secado a mano\" cuando este extra no se ha seleccionado. Esto pasa debido a la validacion en la funcion avanzarFase() , por lo que se intercambia en las asignaciones self.FASE_SECADO_MANO por self.FASE_SECADO_AUTOMATICO y viceversa. Este error no solo se encuentra en el ejemplo 2 , sino que tambien se puede encontrar en el ejemplo 4 # Avanza la fase actual segun el transcurso de la ejecuci\u00f3n y las opciones seleccionadas def avanzarFase(self): if not self.__ocupado: # Si esta ocupado no permitira avanzar de faser return \"\"\" Si esta inactivo se asigna el coste cobrado, se actualiza a la fase cobrando y se muestra por consola el coste cobrado \"\"\" if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO # Si est\u00e1 en la fase \"cobrando\" y se ha marcado \"prelavado a mano\" pasa a la fase \"prelavado a mano\" else: self.__fase = self.FASE_ECHANDO_AGUA # Si est\u00e1 en la fase \"cobrando\" pero no se ha marcado \"prelavado a mano\" pasa a la fase \"echando agua\" elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA # Si est\u00e1 en la fase \"prelavado a mano\" pasa a la fase \"echando agua\" elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO # Si est\u00e1 en la fase \"echando agua\" pasa a la fase \"enjabonando\" elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS # Si esta en la fase \"enjabonando\" pasa a la fase \"rodillos\" elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO # Si est\u00e1 en la fase \"rodillos\" y se ha marcado \"secado a mano\" pasa a la fase \"secado a mano\" else: self.__fase = self.FASE_SECADO_AUTOMATICO # Si est\u00e1 en la fase \"rodillos\" pero no se ha marcado \"secado a mano\" pasa a la fase \"secado autom\u00e1tico\" elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() # Si est\u00e1 en la fase de secado autom\u00e1tico se ejectua la funci\u00f3n terminar() elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO # Si est\u00e1 en la fase \"secado a mano\" y marcado \"encerado\" pasa a la fase \"encerado\", sino ejecuta la funcion terminar() else: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() # Si est\u00e1 en la fase \"encerado\" se ejecuta la funci\u00f3n terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") # Si est\u00e1 en cualquier fase que no sea ninguna de las anteriores se lanza un error en tiempo de ejecuci\u00f3n Ejecuci\u00f3n del programa Una vez solucionados estos errores en el c\u00f3digo, el codigo ya se ejecuta completo y sin errores en la ejecuci\u00f3n, pero para asegurarnos que toda la l\u00f3gica del programa esta funcionando correctamente debemos realizar los tests unitarios (su funci\u00f3n es poder testear todos los casos posibles del programa), pero estos los realizaremos en el siguiente apartado Siguiente paso (test unitarios)->","title":"Documentaci\u00f3n y prueba del programa"},{"location":"documentacionYprueba/#documentacion-y-prueba-del-programa","text":"En este paso se procede a la documentaci\u00f3n del codigo mediante comentarios a lo largo de los dos archivos presentes de codigo fuente, ejecuci\u00f3n del programa y realizar algunos arreglos para que se ejecute correctamente el programa","title":"Documentaci\u00f3n y prueba del programa"},{"location":"documentacionYprueba/#documentacion","text":"A continuaci\u00f3n se muestran los dos archivos documentados: 1-. main_app.py # main_app.py # Importar la clase desde el otro archivo (m\u00f3dulo) from lavadero import Lavadero # MODIFICACI\u00d3N CLAVE AQU\u00cd: La funci\u00f3n ahora acepta 3 argumentos def ejecutarSimulacion(lavadero, prelavado, secado_mano, encerado): \"\"\" Simula el proceso de lavado para un veh\u00edculo con las opciones dadas. Ahora acepta una instancia de lavadero. :param lavadero: Instancia de Lavadero. :param prelavado: bool, True si se solicita prelavado a mano. :param secado_mano: bool, True si se solicita secado a mano. :param encerado: bool, True si se solicita encerado. \"\"\" print(\"--- INICIO: Prueba de Lavado con Opciones Personalizadas ---\") # Mostrar las opciones solicitadas print(f\"Opciones solicitadas: [Prelavado: {prelavado}, Secado a mano: {secado_mano}, Encerado: {encerado}]\") # 1. Iniciar el lavado try: # Esto establece las opciones y pasa a Fase 0 (Inactivo, pero Ocupado=True) lavadero.hacerLavado(prelavado, secado_mano, encerado) print(\"\\nCoche entra. Estado inicial:\") lavadero.imprimir_estado() # 2. Avanza por las fases print(\"\\nAVANZANDO FASE POR FASE:\") # Usamos un contador para evitar bucles infinitos en caso de error o bucles inesperados pasos = 0 while lavadero.ocupado and pasos < 20: # El cobro ahora ocurre en la primera llamada a avanzarFase (transici\u00f3n 0 -> 1) lavadero.avanzarFase() print(f\"-> Fase actual: \", end=\"\") lavadero.imprimir_fase() print() pasos += 1 print(\"\\n----------------------------------------\") print(\"Lavado completo. Estado final:\") lavadero.imprimir_estado() print(f\"Ingresos acumulados: {lavadero.ingresos:.2f} \u20ac\") print(\"----------------------------------------\") except ValueError as e: # Captura la excepci\u00f3n de regla de negocio (Requisito 2) print(f\"ERROR DE ARGUMENTO: {e}\") except RuntimeError as e: # Captura la excepci\u00f3n de estado (Requisito 3) print(f\"ERROR DE ESTADO: {e}\") except Exception as e: print(f\"ERROR INESPERADO: {e}\") # Punto de entrada (main): Aqu\u00ed pasamos los par\u00e1metros if __name__ == \"__main__\": lavadero_global = Lavadero() # Usamos una \u00fanica instancia para acumular ingresos # EJEMPLO 1: Lavado completo con prelavado, secado a mano, con encerado (Requisito 8 y 14) # Precio esperado: 5.00 + 1.50 + 1.00 + 1.20 = 8.70 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 1: Prelavado (S), Secado a mano (S), Encerado (S)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=True, encerado=True) # EJEMPLO 2: Lavado r\u00e1pido sin extras (Requisito 9) # Precio esperado: 5.00 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 2: Sin extras (Prelavado: N, Secado a mano: N, Encerado: N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=False) # EJEMPLO 3: Lavado con encerado, pero sin secado a mano (Debe lanzar ValueError - Requisito 2) print(\"\\n=======================================================\") print(\"EJEMPLO 3: ERROR (Encerado S, Secado a mano N)\") ejecutarSimulacion(lavadero_global, prelavado=False, secado_mano=False, encerado=True) # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False, encerado=False) 2-. lavadero.py # lavadero.py class Lavadero: \"\"\" Simula el estado y las operaciones de un t\u00fanel de lavado de coches. Cumple con los requisitos de estado, avance de fase y reglas de negocio. \"\"\" # Se declaran las constantes con los valores de cada de las fases del lavadero FASE_INACTIVO = 0 FASE_COBRANDO = 1 FASE_PRELAVADO_MANO = 2 FASE_ECHANDO_AGUA = 3 FASE_ENJABONANDO = 4 FASE_RODILLOS = 5 FASE_SECADO_AUTOMATICO = 6 FASE_SECADO_MANO = 7 FASE_ENCERADO = 8 # Constructor para la inicializaci\u00f3n del lavadero def __init__(self): \"\"\" Constructor de la clase. Inicializa el lavadero. Cumple con el requisito 1. \"\"\" self.__ingresos = 0.0 self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False self.terminar() @property def fase(self): return self.__fase @property def ingresos(self): return self.__ingresos @property def ocupado(self): return self.__ocupado @property def prelavado_a_mano(self): return self.__prelavado_a_mano @property def secado_a_mano(self): return self.__secado_a_mano @property def encerado(self): return self.__encerado # Asigna la fase en \"Inactivo\" y resetea las opciones de lavado a \"false\", requisito 1 def terminar(self): self.__fase = self.FASE_INACTIVO self.__ocupado = False self.__prelavado_a_mano = False self.__secado_a_mano = False self.__encerado = False # Inicializa un ciclo de lavado segun los parametros dados y valida que los parametros recibidos sean correctos def hacerLavado(self, prelavado_a_mano, secado_a_mano, encerado): \"\"\" Inicia un nuevo ciclo de lavado, validando reglas de negocio. :raises RuntimeError: Si el lavadero est\u00e1 ocupado (Requisito 3). :raises ValueError: Si se intenta encerar sin secado a mano (Requisito 2). \"\"\" if self.__ocupado: # Si el lavadero est\u00e1 ocupado no se podra iniciar otro lavado diferente raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") if not secado_a_mano and encerado: # Si no esta secado a mano el coche no se podra seleccionar el encerado raise ValueError(\"No se puede encerar el coche sin secado a mano\") # Se asigna el estado del lavado, se reserva el lavadero para este lavado y se asignan las opciones marcadas para el lavado self.__fase = self.FASE_INACTIVO self.__ocupado = True self.__prelavado_a_mano = prelavado_a_mano self.__secado_a_mano = secado_a_mano self.__encerado = encerado # Calcula el coste del lavado a cobrar def _cobrar(self): \"\"\" Calcula y a\u00f1ade los ingresos seg\u00fan las opciones seleccionadas (Requisitos 4-8). Precio base: 5.00\u20ac (Impl\u00edcito, 5.00\u20ac de base + 1.50\u20ac de prelavado + 1.00\u20ac de secado + 1.20\u20ac de encerado = 8.70\u20ac) \"\"\" coste_lavado = 5.00 if self.__prelavado_a_mano: coste_lavado += 1.50 if self.__secado_a_mano: coste_lavado += 1.00 if self.__encerado: coste_lavado += 1.20 self.__ingresos += coste_lavado return coste_lavado # Avanza la fase actual segun el transcurso de la ejecuci\u00f3n y las opciones seleccionadas def avanzarFase(self): if not self.__ocupado: # Si esta ocupado no permitira avanzar de faser return \"\"\" Si esta inactivo se asigna el coste cobrado, se actualiza a la fase cobrando y se muestra por consola el coste cobrado \"\"\" if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO # Si est\u00e1 en la fase \"cobrando\" y se ha marcado \"prelavado a mano\" pasa a la fase \"prelavado a mano\" else: self.__fase = self.FASE_ECHANDO_AGUA # Si est\u00e1 en la fase \"cobrando\" pero no se ha marcado \"prelavado a mano\" pasa a la fase \"echando agua\" elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA # Si est\u00e1 en la fase \"prelavado a mano\" pasa a la fase \"echando agua\" elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO # Si est\u00e1 en la fase \"echando agua\" pasa a la fase \"enjabonando\" elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS # Si esta en la fase \"enjabonando\" pasa a la fase \"rodillos\" elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO # Si est\u00e1 en la fase \"rodillos\" y se ha marcado \"secado a mano\" pasa a la fase \"secado a mano\" else: self.__fase = self.FASE_SECADO_AUTOMATICO # Si est\u00e1 en la fase \"rodillos\" pero no se ha marcado \"secado a mano\" pasa a la fase \"secado autom\u00e1tico\" elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() # Si est\u00e1 en la fase de secado autom\u00e1tico se ejectua la funci\u00f3n terminar() elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO # Si est\u00e1 en la fase \"secado a mano\" y marcado \"encerado\" pasa a la fase \"encerado\", sino ejecuta la funcion terminar() else: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() # Si est\u00e1 en la fase \"encerado\" se ejecuta la funci\u00f3n terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") # Si est\u00e1 en cualquier fase que no sea ninguna de las anteriores se lanza un error en tiempo de ejecuci\u00f3n # Mapea todas las fases posibles en el programa y muestra la fase actual def imprimir_fase(self): fases_map = { self.FASE_INACTIVO: \"0 - Inactivo\", self.FASE_COBRANDO: \"1 - Cobrando\", self.FASE_PRELAVADO_MANO: \"2 - Haciendo prelavado a mano\", self.FASE_ECHANDO_AGUA: \"3 - Ech\u00e1ndole agua\", self.FASE_ENJABONANDO: \"4 - Enjabonando\", self.FASE_RODILLOS: \"5 - Pasando rodillos\", self.FASE_SECADO_AUTOMATICO: \"6 - Haciendo secado autom\u00e1tico\", self.FASE_SECADO_MANO: \"7 - Haciendo secado a mano\", self.FASE_ENCERADO: \"8 - Encerando a mano\", } print(fases_map.get(self.__fase, f\"{self.__fase} - En estado no v\u00e1lido\"), end=\"\") # Muestra el estado de general del lavadero def imprimir_estado(self): print(\"----------------------------------------\") print(f\"Ingresos Acumulados: {self.ingresos:.2f} \u20ac\") print(f\"Ocupado: {self.ocupado}\") print(f\"Prelavado a mano: {self.prelavado_a_mano}\") print(f\"Secado a mano: {self.secado_a_mano}\") print(f\"Encerado: {self.encerado}\") print(\"Fase: \", end=\"\") self.imprimir_fase() print(\"\\n----------------------------------------\") # Esta funci\u00f3n es \u00fatil para pruebas unitarias, no es parte del lavadero real # nos crea un array con las fases visitadas en un ciclo completo def ejecutar_y_obtener_fases(self, prelavado, secado, encerado): \"\"\"Ejecuta un ciclo completo y devuelve la lista de fases visitadas.\"\"\" self.hacerLavado(prelavado, secado, encerado) fases_visitadas = [self.fase] while self.ocupado: # Usamos un l\u00edmite de pasos para evitar bucles infinitos en caso de error if len(fases_visitadas) > 15: raise Exception(\"Bucle infinito detectado en la simulaci\u00f3n de fases.\") self.avanzarFase() fases_visitadas.append(self.fase) return fases_visitadas","title":"Documentaci\u00f3n"},{"location":"documentacionYprueba/#solucion-de-errores-y-ejecucion","text":"Durante el proceso de documentaci\u00f3n y ejecuci\u00f3n se detectan 2 fallos : 1-. main_app.py (linea 83): En la llamada a la funci\u00f3n ejecutarSimulacion() le falta un parametro, el parametro encerado=false # EJEMPLO 4: Lavado con prelavado a mano (Requisito 4 y 10) # Precio esperado: 5.00 + 1.50 = 6.50 \u20ac print(\"\\n=======================================================\") print(\"EJEMPLO 4: Prelavado (S), Secado a mano (N), Encerado (N)\") ejecutarSimulacion(lavadero_global, prelavado=True, secado_mano=False, encerado=False) 2-. lavadero.py (linea 136-141): Error en una de las fases tras realizar un lavado con todos los extras a N (False), ya que al avanzar la fase de \"pasando rodillos\" a \"secado automatico\", pasa a \"secado a mano\" cuando este extra no se ha seleccionado. Esto pasa debido a la validacion en la funcion avanzarFase() , por lo que se intercambia en las asignaciones self.FASE_SECADO_MANO por self.FASE_SECADO_AUTOMATICO y viceversa. Este error no solo se encuentra en el ejemplo 2 , sino que tambien se puede encontrar en el ejemplo 4 # Avanza la fase actual segun el transcurso de la ejecuci\u00f3n y las opciones seleccionadas def avanzarFase(self): if not self.__ocupado: # Si esta ocupado no permitira avanzar de faser return \"\"\" Si esta inactivo se asigna el coste cobrado, se actualiza a la fase cobrando y se muestra por consola el coste cobrado \"\"\" if self.__fase == self.FASE_INACTIVO: coste_cobrado = self._cobrar() self.__fase = self.FASE_COBRANDO print(f\" (COBRADO: {coste_cobrado:.2f} \u20ac) \", end=\"\") elif self.__fase == self.FASE_COBRANDO: if self.__prelavado_a_mano: self.__fase = self.FASE_PRELAVADO_MANO # Si est\u00e1 en la fase \"cobrando\" y se ha marcado \"prelavado a mano\" pasa a la fase \"prelavado a mano\" else: self.__fase = self.FASE_ECHANDO_AGUA # Si est\u00e1 en la fase \"cobrando\" pero no se ha marcado \"prelavado a mano\" pasa a la fase \"echando agua\" elif self.__fase == self.FASE_PRELAVADO_MANO: self.__fase = self.FASE_ECHANDO_AGUA # Si est\u00e1 en la fase \"prelavado a mano\" pasa a la fase \"echando agua\" elif self.__fase == self.FASE_ECHANDO_AGUA: self.__fase = self.FASE_ENJABONANDO # Si est\u00e1 en la fase \"echando agua\" pasa a la fase \"enjabonando\" elif self.__fase == self.FASE_ENJABONANDO: self.__fase = self.FASE_RODILLOS # Si esta en la fase \"enjabonando\" pasa a la fase \"rodillos\" elif self.__fase == self.FASE_RODILLOS: if self.__secado_a_mano: self.__fase = self.FASE_SECADO_MANO # Si est\u00e1 en la fase \"rodillos\" y se ha marcado \"secado a mano\" pasa a la fase \"secado a mano\" else: self.__fase = self.FASE_SECADO_AUTOMATICO # Si est\u00e1 en la fase \"rodillos\" pero no se ha marcado \"secado a mano\" pasa a la fase \"secado autom\u00e1tico\" elif self.__fase == self.FASE_SECADO_AUTOMATICO: self.terminar() # Si est\u00e1 en la fase de secado autom\u00e1tico se ejectua la funci\u00f3n terminar() elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO # Si est\u00e1 en la fase \"secado a mano\" y marcado \"encerado\" pasa a la fase \"encerado\", sino ejecuta la funcion terminar() else: self.terminar() elif self.__fase == self.FASE_ENCERADO: self.terminar() # Si est\u00e1 en la fase \"encerado\" se ejecuta la funci\u00f3n terminar() else: raise RuntimeError(f\"Estado no v\u00e1lido: Fase {self.__fase}. El lavadero va a estallar...\") # Si est\u00e1 en cualquier fase que no sea ninguna de las anteriores se lanza un error en tiempo de ejecuci\u00f3n","title":"Soluci\u00f3n de errores y ejecuci\u00f3n"},{"location":"documentacionYprueba/#ejecucion-del-programa","text":"Una vez solucionados estos errores en el c\u00f3digo, el codigo ya se ejecuta completo y sin errores en la ejecuci\u00f3n, pero para asegurarnos que toda la l\u00f3gica del programa esta funcionando correctamente debemos realizar los tests unitarios (su funci\u00f3n es poder testear todos los casos posibles del programa), pero estos los realizaremos en el siguiente apartado Siguiente paso (test unitarios)->","title":"Ejecuci\u00f3n del programa"},{"location":"ejecucionSandbox/","text":"Ejecuci\u00f3n del programa en un entorno aislado (sandbox) En este \u00faltimo paso se muestra como podemos ejecutar el programa de forma aislada dentro de la misma m\u00e1quina en la que estamos trabajando, esto lo que hace es generar una especie de sistema aislado que no permite que niguna de las ejecuciones o interacciones realizadas en el sistema aislado (Sandbox) repercuta en la maquina real donde se est\u00e1 ejecutando Como ejecutar el programa en un sandbox A continuaci\u00f3n se muestra el proceso paso a paso: Instalaci\u00f3n de FireJail + FireTools : Instalamos FireJail m\u00e1s la extensi\u00f3n de FireTools (Parte gr\u00e1fica de FireJail) mediante el siguiente comando: sudo apt install firejail firetools Ejecuci\u00f3n Firetools : Una vez instalado, podemos comprobar que esta instalado correctamente mediante la ejecuci\u00f3n en la terminal de: firetools A trav\u00e9s de esta interfaz gr\u00e1fica podemos cualquier tipo de ajuste o configuraci\u00f3n de forma grafica sobre FireJail Ejecuci\u00f3n del programa (Lavadero) en FireJail : Ahora vamos al punto m\u00e1s importante, ejecutaremos el programa Lavadero en Sandbox de FireJail mediante el siguiente comando: firejail --private=. python3 src/main_app.py Y podremos ver en la terminal los logs de la ejecuci\u00f3n del programa: Ejecuci\u00f3n de los test del programa (tests Lavadero) en FireJail : Por \u00faltimo, se lanzan los test del programa Lavadero en SandBox de FireJail mediante el siguiente comando: firejail --private=. env PYTHONPATH=src python3 -m unittest discover -v tests Y podremos ver en la terminal los logs de la ejecuci\u00f3n de los test \u00daltimo paso (reflexi\u00f3n final)->","title":"Ejecuci\u00f3n del programa en un entorno aislado (sandbox)"},{"location":"ejecucionSandbox/#ejecucion-del-programa-en-un-entorno-aislado-sandbox","text":"En este \u00faltimo paso se muestra como podemos ejecutar el programa de forma aislada dentro de la misma m\u00e1quina en la que estamos trabajando, esto lo que hace es generar una especie de sistema aislado que no permite que niguna de las ejecuciones o interacciones realizadas en el sistema aislado (Sandbox) repercuta en la maquina real donde se est\u00e1 ejecutando","title":"Ejecuci\u00f3n del programa en un entorno aislado (sandbox)"},{"location":"ejecucionSandbox/#como-ejecutar-el-programa-en-un-sandbox","text":"A continuaci\u00f3n se muestra el proceso paso a paso: Instalaci\u00f3n de FireJail + FireTools : Instalamos FireJail m\u00e1s la extensi\u00f3n de FireTools (Parte gr\u00e1fica de FireJail) mediante el siguiente comando: sudo apt install firejail firetools Ejecuci\u00f3n Firetools : Una vez instalado, podemos comprobar que esta instalado correctamente mediante la ejecuci\u00f3n en la terminal de: firetools A trav\u00e9s de esta interfaz gr\u00e1fica podemos cualquier tipo de ajuste o configuraci\u00f3n de forma grafica sobre FireJail Ejecuci\u00f3n del programa (Lavadero) en FireJail : Ahora vamos al punto m\u00e1s importante, ejecutaremos el programa Lavadero en Sandbox de FireJail mediante el siguiente comando: firejail --private=. python3 src/main_app.py Y podremos ver en la terminal los logs de la ejecuci\u00f3n del programa: Ejecuci\u00f3n de los test del programa (tests Lavadero) en FireJail : Por \u00faltimo, se lanzan los test del programa Lavadero en SandBox de FireJail mediante el siguiente comando: firejail --private=. env PYTHONPATH=src python3 -m unittest discover -v tests Y podremos ver en la terminal los logs de la ejecuci\u00f3n de los test \u00daltimo paso (reflexi\u00f3n final)->","title":"Como ejecutar el programa en un sandbox"},{"location":"reflexion/","text":"Reflexi\u00f3n sobre comparaci\u00f3n de la infraestructura de seguridad de los lenguajes Los distintos lenguajes de programaci\u00f3n incorporan medidas de seguridad que influyen directamente en la forma en la que se desarrollan aplicaciones seguras. Algunos lenguajes incluyen mecanismos de seguridad por defecto que ayudan a prevenir errores comunes, mientras que en otros la seguridad depende en mayor medida del programador. Lenguajes como Python o Java destacan por ofrecer una gesti\u00f3n autom\u00e1tica de memoria, lo que reduce riesgos como desbordamientos de memoria o accesos indebidos, problemas habituales en lenguajes de m\u00e1s bajo nivel. Adem\u00e1s, estos lenguajes cuentan con un amplio ecosistema de librer\u00edas y frameworks que incorporan buenas pr\u00e1cticas de seguridad y facilitan la validaci\u00f3n de datos y el control de errores. Por otro lado, lenguajes como C o C++ ofrecen un mayor control sobre el sistema, pero tambi\u00e9n exigen un conocimiento m\u00e1s profundo por parte del desarrollador, ya que una mala gesti\u00f3n de la memoria o de los punteros puede dar lugar a vulnerabilidades graves. Esto demuestra que la seguridad no depende \u00fanicamente del lenguaje, sino tambi\u00e9n del uso que se haga de \u00e9l. En general, los lenguajes m\u00e1s modernos tienden a priorizar la seguridad mediante restricciones, validaciones autom\u00e1ticas y entornos de ejecuci\u00f3n controlados. Sin embargo, ning\u00fan lenguaje es completamente seguro por s\u00ed mismo, y resulta fundamental que el desarrollador aplique buenas pr\u00e1cticas de programaci\u00f3n y tenga en cuenta la seguridad desde las primeras fases del desarrollo.","title":"Reflexi\u00f3n sobre comparaci\u00f3n de la infraestructura de seguridad de los lenguajes"},{"location":"reflexion/#reflexion-sobre-comparacion-de-la-infraestructura-de-seguridad-de-los-lenguajes","text":"Los distintos lenguajes de programaci\u00f3n incorporan medidas de seguridad que influyen directamente en la forma en la que se desarrollan aplicaciones seguras. Algunos lenguajes incluyen mecanismos de seguridad por defecto que ayudan a prevenir errores comunes, mientras que en otros la seguridad depende en mayor medida del programador. Lenguajes como Python o Java destacan por ofrecer una gesti\u00f3n autom\u00e1tica de memoria, lo que reduce riesgos como desbordamientos de memoria o accesos indebidos, problemas habituales en lenguajes de m\u00e1s bajo nivel. Adem\u00e1s, estos lenguajes cuentan con un amplio ecosistema de librer\u00edas y frameworks que incorporan buenas pr\u00e1cticas de seguridad y facilitan la validaci\u00f3n de datos y el control de errores. Por otro lado, lenguajes como C o C++ ofrecen un mayor control sobre el sistema, pero tambi\u00e9n exigen un conocimiento m\u00e1s profundo por parte del desarrollador, ya que una mala gesti\u00f3n de la memoria o de los punteros puede dar lugar a vulnerabilidades graves. Esto demuestra que la seguridad no depende \u00fanicamente del lenguaje, sino tambi\u00e9n del uso que se haga de \u00e9l. En general, los lenguajes m\u00e1s modernos tienden a priorizar la seguridad mediante restricciones, validaciones autom\u00e1ticas y entornos de ejecuci\u00f3n controlados. Sin embargo, ning\u00fan lenguaje es completamente seguro por s\u00ed mismo, y resulta fundamental que el desarrollador aplique buenas pr\u00e1cticas de programaci\u00f3n y tenga en cuenta la seguridad desde las primeras fases del desarrollo.","title":"Reflexi\u00f3n sobre comparaci\u00f3n de la infraestructura de seguridad de los lenguajes"},{"location":"testUnitarios/","text":"Realizaci\u00f3n de tests unitarios del programa y resoluci\u00f3n de errores En este paso se procede a la realizaci\u00f3n de los tests unitarios del programa para comprobar el correcto funcionamiento en todas las casuisticas posibles del programa Test unitario A continuaci\u00f3n se muestra el archivo del test unitario resultante y los errores encontrados y solucionados gracias a estos: test_lavadero_unittest.py # tests/test_lavadero_unittest.py import unittest # Importamos la clase Lavadero desde el m\u00f3dulo padre from src.lavadero import Lavadero class TestLavadero(unittest.TestCase): # M\u00e9todo que se ejecuta antes de cada test. # Es el equivalente del @pytest.fixture en este contexto. def setUp(self): \"\"\"Prepara una nueva instancia de Lavadero antes de cada prueba.\"\"\" self.lavadero = Lavadero() # ---------------------------------------------------------------------- # Funci\u00f3n para resetear el estado cuanto terminamos una ejecuci\u00f3n de lavado # ---------------------------------------------------------------------- def test_reseteo_estado_con_terminar(self): \"\"\"Test 4: Verifica que terminar() resetea todas las flags y el estado.\"\"\" self.lavadero.hacerLavado(True, True, True) self.lavadero._cobrar() self.lavadero.terminar() self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertTrue(self.lavadero.ingresos > 0) # Los ingresos deben mantenerse # ---------------------------------------------------------------------- # TESTS # ---------------------------------------------------------------------- # Test de comprobacion de estado inicial def test1_estado_inicial_correcto(self): \"\"\"Test 1: Verifica que el estado inicial es Inactivo y con 0 ingresos.\"\"\" self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertEqual(self.lavadero.ingresos, 0.0) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertFalse(self.lavadero.secado_a_mano) self.assertFalse(self.lavadero.encerado) def test2_excepcion_encerado_sin_secado(self): \"\"\"Test 2: Comprueba que encerar sin secado a mano lanza ValueError.\"\"\" with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, True) def test3_excepcion_lavado_con_lavadero_ocupado(self): \"\"\"Test 3: No se puede iniciar un lavado si otro ya est\u00e1 en marcha.\"\"\" self.lavadero.hacerLavado(False, False, False) with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, False) # Test de comprobacion de ingresos segun el tipo de lavado def test4_ingresos_prelavado(self): \"\"\"Test 4: El prelavado a mano debe generar 6,50\u20ac.\"\"\" self.lavadero.hacerLavado(True, False, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 6.50) def test5_ingresos_secado(self): \"\"\"Test 5: Secado a mano debe generar 6,00\u20ac\"\"\" self.lavadero.hacerLavado(False, True, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 6.00) def test6_ingresos_secado_encerado(self): \"\"\"Test 6: Secado + encerado debe generar 7,20\u20ac.\"\"\" self.lavadero.hacerLavado(False, True, True) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 7.20) def test7_ingresos_prelavado_secado(self): \"\"\"Test 7: Prelavado + secado debe generar 7,50\u20ac\"\"\" self.lavadero.hacerLavado(True, True, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 7.50) def test8_ingresos_completo(self): \"\"\"Test 8: Prelavado + secado + encerado debe generar 8,70\u20ac\"\"\" self.lavadero.hacerLavado(True, True, True) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 8.70) # ---------------------------------------------------------------------- # Tests de flujo de fases # Utilizamos la funci\u00f3n def ejecutar_y_obtener_fases(self, prelavado, secado, encerado) # Estos tests dan errores ya que en el c\u00f3digo original hay errores en las las fases esperados, en los saltos. # ---------------------------------------------------------------------- def test9_flujo_rapido_sin_extras(self): \"\"\"Test 9: Simula el flujo r\u00e1pido sin opciones opcionales.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 6, 0] # Ejecutar el ciclo completo y obtener las fases fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(False, False, False) # Verificar que las fases obtenidas coinciden con las esperadas self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\") def test10_flujo_prelavado(self): \"\"\"Test 10: Flujo con prelavado.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(True, False, False) self.assertEqual(fases_obtenidas, fases_esperadas) def test11_flujo_secado(self): \"\"\"Test 11: Flujo con secado.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(False, True, False) self.assertEqual(fases_obtenidas, fases_esperadas) def test12_flujo_secado_encerado(self): \"\"\"Test 12: Flujo con secado y encerado.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(False, True, True) self.assertEqual(fases_obtenidas, fases_esperadas) def test13_flujo_prelavado_secado(self): \"\"\"Test 13: Flujo con prelavado y secado.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(True, True, False) self.assertEqual(fases_obtenidas, fases_esperadas) def test14_flujo_completo(self): \"\"\"Test 14: Flujo con prelavado, secado y encerado.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(True, True, True) self.assertEqual(fases_obtenidas, fases_esperadas) # Test final completo def test15_reseteo_estado_con_terminar(self): \"\"\"Test extra completo: terminar() debe resetear estador y mantener ingresos.\"\"\" self.lavadero.hacerLavado(True, True, True) self.lavadero._cobrar() self.lavadero.terminar() self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertTrue(self.lavadero.ingresos > 0) # Bloque de ejecuci\u00f3n para ejecutar los tests si el archivo es corrido directamente if __name__ == '__main__': unittest.main() C\u00f3digo completo del archivo que contiene el test unitario en el que se testean todas las casuisticas posibles Resoluci\u00f3n de errores Una vez que ejecutemos el test que se muestra anteriormente con el comando: python -m unittest ./tests/test_lavadero_unittest.py -v Cuando lo ejecutamos, en este caso se presentaban errores en el codigo, por lo que en la terminal vamos encontrando todos los logs de cada uno de los test, tanto el que esta OK, como el que presenta un error, los que presentan error, adem\u00e1s, a\u00f1aden un trazo que nos ayuda a identificar el donde se encuentra exactamente el error. Errores solucionados en el programa mediante los tests: test_lavadero_unittest.py (Linea 20 y 46) : Mediante los test se encuentra errores en las llamadas a la funci\u00f3n _hacer_lavado() de lavadero.py , mientras que la llamada correcta a la funci\u00f3n es hacerLavado() . self.lavadero.hacerLavado(True, True, True) Linea 20 self.lavadero.hacerLavado(False, False, True) Linea 46 test_lavadero_unittest.py (Linea 98) : En la llamada a la funci\u00f3n assertEqual() falta el paso de los parametros fases esperadas y fases obtenidas para que la funci\u00f3n pueda compararlos y comprobar que se obtiene el resultado esperado. # Verificar que las fases obtenidas coinciden con las esperadas self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\") Linea 98 lavadero.py (Linea 145) : Mediante los test, tras un fallo en el test n\u00ba12, la funcion avanzarFase() en lavadero.py presenta un error. Este es, que cuando entraba en la fase secado a mano directamente terminaba, mientras que lo que tenia que hacer es pasar a la fase de encerado siempre que estuviera marcado el encerado y sino, cuando pasara por esta fase terminar, mientras no. elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO # Si est\u00e1 en la fase \"secado a mano\" y marcado \"encerado\" pasa a la fase \"encerado\", sino ejecuta la funcion terminar() else: self.terminar() Linea 145 lavadero.py (Linea 98 y 101) : Mediante los test, tras un fallo en el test n\u00ba5 se descubre que los valores que se sumen en la funci\u00f3n cobrar() del coste de secado a mano estaba sumando 1,20\u20ac en vez de 1,00\u20ac y en el encerado 1,00\u20ac en vez de 1,20\u20ac . if self.__secado_a_mano: coste_lavado += 1.00 Linea 98 if self.__encerado: coste_lavado += 1.20 Linea 101 lavadero.py (Linea 74) : Mediante el test n\u00ba3 se descubre que la excepci\u00f3n arrojada por la funci\u00f3n hacerLavado() en lavadero.py cuando se intenta realizar un lavado estando el lavadero ocupado es incorrecta, ya que est\u00e1 como runTimeError y deber\u00eda ser valueError . if self.__ocupado: # Si el lavadero est\u00e1 ocupado no se podra iniciar otro lavado diferente raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") Linea 74 Test completados Finalmente, tras realizar los test y gracias a estos ir arreglando los fallos encontrados conseguimos un codigo muchos mas robusto, testeado y libre de errores. Una vez que todos los test que hemos programado hayan pasado satisfactoriamente debe aparecer la siguiente informaci\u00f3n en la terminal donde se ejecuten. Siguiente paso (ejecuci\u00f3n en SandBox)->","title":"Realizaci\u00f3n de tests unitarios del programa y resoluci\u00f3n de errores"},{"location":"testUnitarios/#realizacion-de-tests-unitarios-del-programa-y-resolucion-de-errores","text":"En este paso se procede a la realizaci\u00f3n de los tests unitarios del programa para comprobar el correcto funcionamiento en todas las casuisticas posibles del programa","title":"Realizaci\u00f3n de tests unitarios del programa y resoluci\u00f3n de errores"},{"location":"testUnitarios/#test-unitario","text":"A continuaci\u00f3n se muestra el archivo del test unitario resultante y los errores encontrados y solucionados gracias a estos: test_lavadero_unittest.py # tests/test_lavadero_unittest.py import unittest # Importamos la clase Lavadero desde el m\u00f3dulo padre from src.lavadero import Lavadero class TestLavadero(unittest.TestCase): # M\u00e9todo que se ejecuta antes de cada test. # Es el equivalente del @pytest.fixture en este contexto. def setUp(self): \"\"\"Prepara una nueva instancia de Lavadero antes de cada prueba.\"\"\" self.lavadero = Lavadero() # ---------------------------------------------------------------------- # Funci\u00f3n para resetear el estado cuanto terminamos una ejecuci\u00f3n de lavado # ---------------------------------------------------------------------- def test_reseteo_estado_con_terminar(self): \"\"\"Test 4: Verifica que terminar() resetea todas las flags y el estado.\"\"\" self.lavadero.hacerLavado(True, True, True) self.lavadero._cobrar() self.lavadero.terminar() self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertTrue(self.lavadero.ingresos > 0) # Los ingresos deben mantenerse # ---------------------------------------------------------------------- # TESTS # ---------------------------------------------------------------------- # Test de comprobacion de estado inicial def test1_estado_inicial_correcto(self): \"\"\"Test 1: Verifica que el estado inicial es Inactivo y con 0 ingresos.\"\"\" self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertEqual(self.lavadero.ingresos, 0.0) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertFalse(self.lavadero.secado_a_mano) self.assertFalse(self.lavadero.encerado) def test2_excepcion_encerado_sin_secado(self): \"\"\"Test 2: Comprueba que encerar sin secado a mano lanza ValueError.\"\"\" with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, True) def test3_excepcion_lavado_con_lavadero_ocupado(self): \"\"\"Test 3: No se puede iniciar un lavado si otro ya est\u00e1 en marcha.\"\"\" self.lavadero.hacerLavado(False, False, False) with self.assertRaises(ValueError): self.lavadero.hacerLavado(False, False, False) # Test de comprobacion de ingresos segun el tipo de lavado def test4_ingresos_prelavado(self): \"\"\"Test 4: El prelavado a mano debe generar 6,50\u20ac.\"\"\" self.lavadero.hacerLavado(True, False, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 6.50) def test5_ingresos_secado(self): \"\"\"Test 5: Secado a mano debe generar 6,00\u20ac\"\"\" self.lavadero.hacerLavado(False, True, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 6.00) def test6_ingresos_secado_encerado(self): \"\"\"Test 6: Secado + encerado debe generar 7,20\u20ac.\"\"\" self.lavadero.hacerLavado(False, True, True) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 7.20) def test7_ingresos_prelavado_secado(self): \"\"\"Test 7: Prelavado + secado debe generar 7,50\u20ac\"\"\" self.lavadero.hacerLavado(True, True, False) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 7.50) def test8_ingresos_completo(self): \"\"\"Test 8: Prelavado + secado + encerado debe generar 8,70\u20ac\"\"\" self.lavadero.hacerLavado(True, True, True) self.lavadero._cobrar() self.assertEqual(self.lavadero.ingresos, 8.70) # ---------------------------------------------------------------------- # Tests de flujo de fases # Utilizamos la funci\u00f3n def ejecutar_y_obtener_fases(self, prelavado, secado, encerado) # Estos tests dan errores ya que en el c\u00f3digo original hay errores en las las fases esperados, en los saltos. # ---------------------------------------------------------------------- def test9_flujo_rapido_sin_extras(self): \"\"\"Test 9: Simula el flujo r\u00e1pido sin opciones opcionales.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 6, 0] # Ejecutar el ciclo completo y obtener las fases fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(False, False, False) # Verificar que las fases obtenidas coinciden con las esperadas self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\") def test10_flujo_prelavado(self): \"\"\"Test 10: Flujo con prelavado.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 6, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(True, False, False) self.assertEqual(fases_obtenidas, fases_esperadas) def test11_flujo_secado(self): \"\"\"Test 11: Flujo con secado.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(False, True, False) self.assertEqual(fases_obtenidas, fases_esperadas) def test12_flujo_secado_encerado(self): \"\"\"Test 12: Flujo con secado y encerado.\"\"\" fases_esperadas = [0, 1, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(False, True, True) self.assertEqual(fases_obtenidas, fases_esperadas) def test13_flujo_prelavado_secado(self): \"\"\"Test 13: Flujo con prelavado y secado.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(True, True, False) self.assertEqual(fases_obtenidas, fases_esperadas) def test14_flujo_completo(self): \"\"\"Test 14: Flujo con prelavado, secado y encerado.\"\"\" fases_esperadas = [0, 1, 2, 3, 4, 5, 7, 8, 0] fases_obtenidas = self.lavadero.ejecutar_y_obtener_fases(True, True, True) self.assertEqual(fases_obtenidas, fases_esperadas) # Test final completo def test15_reseteo_estado_con_terminar(self): \"\"\"Test extra completo: terminar() debe resetear estador y mantener ingresos.\"\"\" self.lavadero.hacerLavado(True, True, True) self.lavadero._cobrar() self.lavadero.terminar() self.assertEqual(self.lavadero.fase, Lavadero.FASE_INACTIVO) self.assertFalse(self.lavadero.ocupado) self.assertFalse(self.lavadero.prelavado_a_mano) self.assertTrue(self.lavadero.ingresos > 0) # Bloque de ejecuci\u00f3n para ejecutar los tests si el archivo es corrido directamente if __name__ == '__main__': unittest.main() C\u00f3digo completo del archivo que contiene el test unitario en el que se testean todas las casuisticas posibles","title":"Test unitario"},{"location":"testUnitarios/#resolucion-de-errores","text":"Una vez que ejecutemos el test que se muestra anteriormente con el comando: python -m unittest ./tests/test_lavadero_unittest.py -v Cuando lo ejecutamos, en este caso se presentaban errores en el codigo, por lo que en la terminal vamos encontrando todos los logs de cada uno de los test, tanto el que esta OK, como el que presenta un error, los que presentan error, adem\u00e1s, a\u00f1aden un trazo que nos ayuda a identificar el donde se encuentra exactamente el error. Errores solucionados en el programa mediante los tests: test_lavadero_unittest.py (Linea 20 y 46) : Mediante los test se encuentra errores en las llamadas a la funci\u00f3n _hacer_lavado() de lavadero.py , mientras que la llamada correcta a la funci\u00f3n es hacerLavado() . self.lavadero.hacerLavado(True, True, True) Linea 20 self.lavadero.hacerLavado(False, False, True) Linea 46 test_lavadero_unittest.py (Linea 98) : En la llamada a la funci\u00f3n assertEqual() falta el paso de los parametros fases esperadas y fases obtenidas para que la funci\u00f3n pueda compararlos y comprobar que se obtiene el resultado esperado. # Verificar que las fases obtenidas coinciden con las esperadas self.assertEqual( fases_obtenidas, fases_esperadas, f\"Secuencia de fases incorrecta.\\nEsperadas: {fases_esperadas}\\nObtenidas: {fases_obtenidas}\") Linea 98 lavadero.py (Linea 145) : Mediante los test, tras un fallo en el test n\u00ba12, la funcion avanzarFase() en lavadero.py presenta un error. Este es, que cuando entraba en la fase secado a mano directamente terminaba, mientras que lo que tenia que hacer es pasar a la fase de encerado siempre que estuviera marcado el encerado y sino, cuando pasara por esta fase terminar, mientras no. elif self.__fase == self.FASE_SECADO_MANO: if self.__encerado: self.__fase = self.FASE_ENCERADO # Si est\u00e1 en la fase \"secado a mano\" y marcado \"encerado\" pasa a la fase \"encerado\", sino ejecuta la funcion terminar() else: self.terminar() Linea 145 lavadero.py (Linea 98 y 101) : Mediante los test, tras un fallo en el test n\u00ba5 se descubre que los valores que se sumen en la funci\u00f3n cobrar() del coste de secado a mano estaba sumando 1,20\u20ac en vez de 1,00\u20ac y en el encerado 1,00\u20ac en vez de 1,20\u20ac . if self.__secado_a_mano: coste_lavado += 1.00 Linea 98 if self.__encerado: coste_lavado += 1.20 Linea 101 lavadero.py (Linea 74) : Mediante el test n\u00ba3 se descubre que la excepci\u00f3n arrojada por la funci\u00f3n hacerLavado() en lavadero.py cuando se intenta realizar un lavado estando el lavadero ocupado es incorrecta, ya que est\u00e1 como runTimeError y deber\u00eda ser valueError . if self.__ocupado: # Si el lavadero est\u00e1 ocupado no se podra iniciar otro lavado diferente raise ValueError(\"No se puede iniciar un nuevo lavado mientras el lavadero est\u00e1 ocupado\") Linea 74","title":"Resoluci\u00f3n de errores"},{"location":"testUnitarios/#test-completados","text":"Finalmente, tras realizar los test y gracias a estos ir arreglando los fallos encontrados conseguimos un codigo muchos mas robusto, testeado y libre de errores. Una vez que todos los test que hemos programado hayan pasado satisfactoriamente debe aparecer la siguiente informaci\u00f3n en la terminal donde se ejecuten. Siguiente paso (ejecuci\u00f3n en SandBox)->","title":"Test completados"}]}